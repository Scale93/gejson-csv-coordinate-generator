{"version":3,"sources":["webpack://geotools/webpack/universalModuleDefinition","webpack://geotools/webpack/bootstrap","webpack://geotools/./node_modules/@turf/boolean-point-in-polygon/main.es.js","webpack://geotools/./node_modules/@turf/invariant/main.es.js","webpack://geotools/./node_modules/@turf/helpers/index.js","webpack://geotools/./node_modules/rbush/index.js","webpack://geotools/./index.js","webpack://geotools/./lib/random-points.js","webpack://geotools/./lib/turf.js","webpack://geotools/./node_modules/quickselect/quickselect.js","webpack://geotools/./node_modules/@turf/random/index.js","webpack://geotools/./node_modules/@turf/bbox/index.js","webpack://geotools/./node_modules/@turf/meta/index.js","webpack://geotools/./node_modules/@turf/unkink-polygon/node_modules/@turf/helpers/main.es.js","webpack://geotools/./node_modules/@turf/unkink-polygon/node_modules/@turf/meta/main.es.js","webpack://geotools/./node_modules/@turf/area/node_modules/@turf/meta/main.es.js","webpack://geotools/./node_modules/@turf/area/main.es.js","webpack://geotools/./node_modules/@turf/unkink-polygon/main.es.js","webpack://geotools/./node_modules/@turf/points-within-polygon/node_modules/@turf/helpers/main.es.js","webpack://geotools/./node_modules/@turf/points-within-polygon/node_modules/@turf/meta/main.es.js","webpack://geotools/./node_modules/@turf/points-within-polygon/main.es.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","inRing","pt","ring","ignoreBoundary","isInside","length","slice","j","xi","yi","xj","yj","point","polygon","options","Error","coord","type","geometry","coordinates","Array","isArray","undefined","getCoord","polys","coords","getCoords","bbox","inBBox","insidePoly","inHole","k","feature","geom","properties","feat","id","_i","coordinates_1","lineString","featureCollection","features","fc","multiLineString","multiPoint","multiPolygon","radiansToLength","radians","units","factor","factors","lengthToRadians","distance","radiansToDegrees","Math","PI","isNumber","num","isNaN","test","earthRadius","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","yards","unitsFactors","areaFactors","acres","points","map","polygons","lineStrings","geometryCollection","geometries","round","precision","multiplier","pow","lengthToDegrees","bearingToAzimuth","bearing","angle","degreesToRadians","convertLength","originalUnit","finalUnit","convertArea","area","startFactor","finalFactor","isObject","input","constructor","validateBBox","forEach","validateId","indexOf","radians2degrees","degrees2radians","distanceToDegrees","distanceToRadians","radiansToDistance","bearingToAngle","convertDistance","rbush","default","quickselect","maxEntries","format","this","_maxEntries","max","_minEntries","ceil","_initFormat","clear","findItem","item","items","equalsFn","calcBBox","node","toBBox","distBBox","children","destNode","createNode","minX","Infinity","minY","maxX","maxY","child","extend","leaf","a","b","min","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","contains","intersects","height","multiSelect","arr","left","right","compare","mid","stack","pop","push","all","_all","data","search","result","len","childBBox","nodesToSearch","collides","load","insert","_build","_splitRoot","tmpNode","_insert","remove","parent","index","goingUp","path","indexes","splice","_condense","compareMinX","compareMinY","toJSON","fromJSON","apply","N","M","log","right2","right3","N2","N1","sqrt","_chooseSubtree","level","targetNode","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","_allDistMargin","sort","leftBBox","rightBBox","margin","siblings","compareArr","Function","join","randomPoints","random","turf","number","params","geojson","unkinkPolygon","ori","flag","joker","thePoints","randomPoint","ptsWithin","pointsWithinPolygon","randomPointsFromGeoJSON","count","helpers","swap","tmp","defaultCompare","quickselectStep","z","exp","sd","newLeft","floor","newRight","helpers_1","randomPosition","coordInBBox","rnd","randomPolygon","num_vertices","max_radial_length","_loop_1","hub","vertices","circleOffsets","cur","radialScaler","sin","cos","randomLineString","max_length","max_rotation","tan","meta_1","coordEach","callback","excludeWrapCoord","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","propEach","featureEach","geomEach","g","featureProperties","featureBBox","featureId","flattenEach","segmentEach","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","currentCoord","featureIndexCoord","multiPartIndexCoord","currentSegment","lineEach","coordReduce","initialValue","previousValue","propReduce","currentProperties","featureReduce","currentFeature","coordAll","geomReduce","currentGeometry","flattenReduce","segmentReduce","started","lineReduce","currentLine","findSegment","findPoint","coordinate","RADIUS","polygonArea","abs","ringArea","p1","p2","lowerIndex","middleIndex","upperIndex","coordsLength","rad","_","calculateArea","isects","filterFn","useSpatialIndex","output","seen","allEdgesAsRbushTreeItems","ring0","edge0","rbushTreeItem","tree","ringA","edgeA","bboxIsect","ring1","edge1","edge","ifIsectAddToOutput","frac0","frac1","start0","end0","start1","end1","isect","equalArrays$1","x0","y0","x1","y1","x2","y2","x3","y3","denom","intersect","unique","start","end","array1","array2","simplepolygon","numRings","equalArrays","array","u","isUnique","numvertices","selfIsectsData","numSelfIsect","outputFeatureArray","winding","windingOfRing","determineParents","setNetWinding","pseudoVtxListByRingAndEdge","isectList","PseudoVtx","modulo","Isect","numIsect","param","allIsectsAsIsectRbushTreeItem","isectRbushTree","coordToFind","IsectRbushTreeItemFound","nxtIsectAlongEdgeIn","nxtIsectAlongRingAndEdge2","ringAndEdge1","ringAndEdgeIn","nxtIsectAlongRingAndEdge1","queue","leftIsect","isectAfterLeftIsect","isectBeforeLeftIsect","windingAtIsect","isConvex","popped","startIsect","currentOutputRingParent","currentOutputRingWinding","currentOutputRing","currentOutputRingCoords","currentIsect","ringAndEdge1Walkable","walkingRingAndEdge","nxtIsect","ringAndEdge2","nxtIsectInQueue","ringAndEdge2Walkable","pushing","netWinding","featuresWithoutParent","setNetWindingOfChildren","ParentNetWinding","ringAndEdgeOut","pts","righthanded","leftVtx","Number","poly","results"],"mappings":"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","file":"random-points.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"geotools\"] = factory();\n\telse\n\t\troot[\"geotools\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","import { getCoord, getCoords } from '@turf/invariant';\n\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can\n * be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nfunction booleanPointInPolygon(point, polygon, options) {\n    // Optional parameters\n    options = options || {};\n    if (typeof options !== 'object') throw new Error('options is invalid');\n    var ignoreBoundary = options.ignoreBoundary;\n\n    // validation\n    if (!point) throw new Error('point is required');\n    if (!polygon) throw new Error('polygon is required');\n\n    var pt = getCoord(point);\n    var polys = getCoords(polygon);\n    var type = (polygon.geometry) ? polygon.geometry.type : polygon.type;\n    var bbox = polygon.bbox;\n\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) return false;\n\n    // normalize to multipolygon\n    if (type === 'Polygon') polys = [polys];\n\n    for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) insidePoly = true;\n        }\n    }\n    return insidePoly;\n}\n\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);\n\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0], yi = ring[i][1];\n        var xj = ring[j][0], yj = ring[j][1];\n        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&\n            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);\n        if (onBoundary) return !ignoreBoundary;\n        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&\n        (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n        if (intersect) isInside = !isInside;\n    }\n    return isInside;\n}\n\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return bbox[0] <= pt[0] &&\n           bbox[1] <= pt[1] &&\n           bbox[2] >= pt[0] &&\n           bbox[3] >= pt[1];\n}\n\nexport default booleanPointInPolygon;\n","import { isNumber } from '@turf/helpers';\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord) {\n    if (!coord) throw new Error('coord is required');\n    if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;\n    if (coord.type === 'Point') return coord.coordinates;\n    if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;\n\n    throw new Error('coord must be GeoJSON Point or an Array of numbers');\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(coords) {\n    if (!coords) throw new Error('coords is required');\n\n    // Feature\n    if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n\n    // Geometry\n    if (coords.coordinates) return coords.coordinates;\n\n    // Array of numbers\n    if (Array.isArray(coords)) return coords;\n\n    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nfunction getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\nexport { getCoord, getCoords, containsNumber, geojsonType, featureOf, collectionOf, getGeom, getGeomType, getType };\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n","'use strict';\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","const randomPoints = require('./lib/random-points');\n\nmodule.exports = {\n  random: randomPoints,\n};\n","const turf = require('./turf');\n\nconst DEFAULT_NUMBER = 10;\n\nconst randomPoints = (n, bbox) => {\n  const count = n || DEFAULT_NUMBER;\n  return turf.randomPoint(count, {\n    bbox,\n  });\n};\n\nconst randomPointsFromGeoJSON = (input, geojson) => {\n  const fc = turf.unkinkPolygon(geojson);\n\n  const ori = input || DEFAULT_NUMBER;\n  const features = [];\n  const bbox = turf.bbox(fc);\n  let n = ori;\n  let flag = false;\n  let joker = 0;\n\n  while (!flag) {\n    const thePoints = turf.randomPoint(n, {\n      bbox,\n    });\n    joker += 1;\n    const ptsWithin = turf.pointsWithinPolygon(thePoints, fc);\n    for (let i = 0; i < ptsWithin.features.length; i += 1) {\n      features.push(ptsWithin.features[i]);\n    }\n    if (features.length < ori) {\n      n = ori - features.length;\n    } else {\n      flag = true;\n    }\n    if (joker > ori * 100) {\n      throw new Error(\n        'Your are not lucky. Ending without reaching expected number of Points with input polygon(s)'\n      );\n    }\n  }\n  return turf.featureCollection(features);\n};\n\n/**\n * Creates random points and returns it as a FeatureCollecion\n * @param  {Number} number of points to generate\n * @param  {Object} options for random [bbox|input]\n * @return FeatureCollection generated random points\n */\nmodule.exports = (number, options) => {\n  let points;\n  let params = options;\n  if (params === undefined) {\n    params = {};\n  }\n\n  if (params.features !== undefined) {\n    points = randomPointsFromGeoJSON(number, params.features);\n  } else {\n    points = randomPoints(number, params.bbox);\n  }\n\n  return points;\n};\n","const unkinkPolygon = require('@turf/unkink-polygon');\nconst random = require('@turf/random');\nconst bbox = require('@turf/bbox');\nconst pointsWithinPolygon = require('@turf/points-within-polygon');\nconst helpers = require('@turf/helpers');\n\nmodule.exports = {\n  randomPoint: random.randomPoint,\n  unkinkPolygon,\n  bbox: bbox.default,\n  pointsWithinPolygon,\n  featureCollection: helpers.featureCollection,\n};\n","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.quickselect = factory());\n}(this, (function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nreturn quickselect;\n\n})));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = require(\"@turf/helpers\");\n/**\n * Returns a random position within a {@link bounding box}.\n *\n * @name randomPosition\n * @param {Array<number>} [bbox=[-180, -90, 180, 90]] a bounding box inside of which positions are placed.\n * @returns {Array<number>} Position [longitude, latitude]\n * @example\n * var position = turf.randomPosition([-180, -90, 180, 90])\n * // => position\n */\nfunction randomPosition(bbox) {\n    if (Array.isArray(bbox)) {\n        return coordInBBox(bbox);\n    }\n    if (bbox && bbox.bbox) {\n        return coordInBBox(bbox.bbox);\n    }\n    return [lon(), lat()];\n}\nexports.randomPosition = randomPosition;\n/**\n * Returns a random {@link point}.\n *\n * @name randomPoint\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @returns {FeatureCollection<Point>} GeoJSON FeatureCollection of points\n * @example\n * var points = turf.randomPoint(25, {bbox: [-180, -90, 180, 90]})\n * // => points\n */\nfunction randomPoint(count, options) {\n    if (options === void 0) { options = {}; }\n    if (count === undefined || count === null) {\n        count = 1;\n    }\n    var features = [];\n    for (var i = 0; i < count; i++) {\n        features.push(helpers_1.point(randomPosition(options.bbox)));\n    }\n    return helpers_1.featureCollection(features);\n}\nexports.randomPoint = randomPoint;\n/**\n * Returns a random {@link polygon}.\n *\n * @name randomPolygon\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.\n * @param {number} [options.max_radial_length=10] is the maximum number of decimal degrees latitude or longitude that a\n * vertex can reach out of the center of the Polygon.\n * @returns {FeatureCollection<Polygon>} GeoJSON FeatureCollection of polygons\n * @example\n * var polygons = turf.randomPolygon(25, {bbox: [-180, -90, 180, 90]})\n * // => polygons\n */\nfunction randomPolygon(count, options) {\n    if (options === void 0) { options = {}; }\n    // Default param\n    if (count === undefined || count === null) {\n        count = 1;\n    }\n    if (!helpers_1.isNumber(options.num_vertices) || options.num_vertices === undefined) {\n        options.num_vertices = 10;\n    }\n    if (!helpers_1.isNumber(options.max_radial_length) || options.max_radial_length === undefined) {\n        options.max_radial_length = 10;\n    }\n    var features = [];\n    var _loop_1 = function (i) {\n        var vertices = [];\n        var circleOffsets = Array.apply(null, new Array(options.num_vertices + 1)).map(Math.random);\n        // Sum Offsets\n        circleOffsets.forEach(function (cur, index, arr) {\n            arr[index] = (index > 0) ? cur + arr[index - 1] : cur;\n        });\n        // scaleOffsets\n        circleOffsets.forEach(function (cur) {\n            cur = cur * 2 * Math.PI / circleOffsets[circleOffsets.length - 1];\n            var radialScaler = Math.random();\n            vertices.push([\n                radialScaler * (options.max_radial_length || 10) * Math.sin(cur),\n                radialScaler * (options.max_radial_length || 10) * Math.cos(cur),\n            ]);\n        });\n        vertices[vertices.length - 1] = vertices[0]; // close the ring\n        // center the polygon around something\n        vertices = vertices.map(vertexToCoordinate(randomPosition(options.bbox)));\n        features.push(helpers_1.polygon([vertices]));\n    };\n    for (var i = 0; i < count; i++) {\n        _loop_1(i);\n    }\n    return helpers_1.featureCollection(features);\n}\nexports.randomPolygon = randomPolygon;\n/**\n * Returns a random {@link linestring}.\n *\n * @name randomLineString\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.\n * @param {number} [options.max_length=0.0001] is the maximum number of decimal degrees that a\n * vertex can be from its predecessor\n * @param {number} [options.max_rotation=Math.PI / 8] is the maximum number of radians that a\n * line segment can turn from the previous segment.\n * @returns {FeatureCollection<LineString>} GeoJSON FeatureCollection of linestrings\n * @example\n * var lineStrings = turf.randomLineString(25, {bbox: [-180, -90, 180, 90]})\n * // => lineStrings\n */\nfunction randomLineString(count, options) {\n    if (options === void 0) { options = {}; }\n    // Optional parameters\n    options = options || {};\n    if (!helpers_1.isObject(options)) {\n        throw new Error(\"options is invalid\");\n    }\n    var bbox = options.bbox;\n    var num_vertices = options.num_vertices;\n    var max_length = options.max_length;\n    var max_rotation = options.max_rotation;\n    if (count === undefined || count === null) {\n        count = 1;\n    }\n    // Default parameters\n    if (!helpers_1.isNumber(num_vertices) || num_vertices === undefined || num_vertices < 2) {\n        num_vertices = 10;\n    }\n    if (!helpers_1.isNumber(max_length) || max_length === undefined) {\n        max_length = 0.0001;\n    }\n    if (!helpers_1.isNumber(max_rotation) || max_rotation === undefined) {\n        max_rotation = Math.PI / 8;\n    }\n    var features = [];\n    for (var i = 0; i < count; i++) {\n        var startingPoint = randomPosition(bbox);\n        var vertices = [startingPoint];\n        for (var j = 0; j < num_vertices - 1; j++) {\n            var priorAngle = (j === 0) ?\n                Math.random() * 2 * Math.PI :\n                Math.tan((vertices[j][1] - vertices[j - 1][1]) /\n                    (vertices[j][0] - vertices[j - 1][0]));\n            var angle = priorAngle + (Math.random() - 0.5) * max_rotation * 2;\n            var distance = Math.random() * max_length;\n            vertices.push([\n                vertices[j][0] + distance * Math.cos(angle),\n                vertices[j][1] + distance * Math.sin(angle),\n            ]);\n        }\n        features.push(helpers_1.lineString(vertices));\n    }\n    return helpers_1.featureCollection(features);\n}\nexports.randomLineString = randomLineString;\nfunction vertexToCoordinate(hub) {\n    return function (cur) {\n        return [cur[0] + hub[0], cur[1] + hub[1]];\n    };\n}\nfunction rnd() { return Math.random() - 0.5; }\nfunction lon() { return rnd() * 360; }\nfunction lat() { return rnd() * 180; }\nfunction coordInBBox(bbox) {\n    return [\n        (Math.random() * (bbox[2] - bbox[0])) + bbox[0],\n        (Math.random() * (bbox[3] - bbox[1])) + bbox[1]\n    ];\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    meta_1.coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nexports.default = bbox;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { feature, isObject, lineString, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","import { feature, isObject, lineString, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","import { geomReduce } from '@turf/meta';\n\n/**\n * Takes one or more features and returns their area in square meters.\n *\n * @name area\n * @param {GeoJSON} geojson input GeoJSON feature(s)\n * @returns {number} area in square meters\n * @example\n * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);\n *\n * var area = turf.area(polygon);\n *\n * //addToMap\n * var addToMap = [polygon]\n * polygon.properties.area = area\n */\nfunction area(geojson) {\n    return geomReduce(geojson, function (value, geom) {\n        return value + calculateArea(geom);\n    }, 0);\n}\n\nvar RADIUS = 6378137;\n// var FLATTENING_DENOM = 298.257223563;\n// var FLATTENING = 1 / FLATTENING_DENOM;\n// var POLAR_RADIUS = RADIUS * (1 - FLATTENING);\n\n/**\n * Calculate Area\n *\n * @private\n * @param {GeoJSON} geojson GeoJSON\n * @returns {number} area\n */\nfunction calculateArea(geojson) {\n    var area = 0, i;\n    switch (geojson.type) {\n    case 'Polygon':\n        return polygonArea(geojson.coordinates);\n    case 'MultiPolygon':\n        for (i = 0; i < geojson.coordinates.length; i++) {\n            area += polygonArea(geojson.coordinates[i]);\n        }\n        return area;\n    case 'Point':\n    case 'MultiPoint':\n    case 'LineString':\n    case 'MultiLineString':\n        return 0;\n    case 'GeometryCollection':\n        for (i = 0; i < geojson.geometries.length; i++) {\n            area += calculateArea(geojson.geometries[i]);\n        }\n        return area;\n    }\n}\n\nfunction polygonArea(coords) {\n    var area = 0;\n    if (coords && coords.length > 0) {\n        area += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            area -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return area;\n}\n\n/**\n * @private\n * Calculate the approximate area of the polygon were it projected onto the earth.\n * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * @param {Array<Array<number>>} coords Ring Coordinates\n * @returns {number} The approximate signed geodesic area of the polygon in square meters.\n */\nfunction ringArea(coords) {\n    var p1;\n    var p2;\n    var p3;\n    var lowerIndex;\n    var middleIndex;\n    var upperIndex;\n    var i;\n    var area = 0;\n    var coordsLength = coords.length;\n\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) { // i = N-2\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength - 1;\n                upperIndex = 0;\n            } else if (i === coordsLength - 1) { // i = N-1\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            } else { // i = 0 to N-3\n                lowerIndex = i;\n                middleIndex = i + 1;\n                upperIndex = i + 2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            area += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));\n        }\n\n        area = area * RADIUS * RADIUS / 2;\n    }\n\n    return area;\n}\n\nfunction rad(_) {\n    return _ * Math.PI / 180;\n}\n\nexport default area;\n","import { featureEach, flattenEach } from '@turf/meta';\nimport { featureCollection, polygon } from '@turf/helpers';\nimport rbush from 'rbush';\nimport area from '@turf/area';\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\n\n// Find self-intersections in geojson polygon (possibly with interior rings)\nvar isects = function (feature, filterFn, useSpatialIndex) {\n    if (feature.geometry.type !== 'Polygon') throw new Error('The input feature must be a Polygon');\n    if (useSpatialIndex === undefined) useSpatialIndex = 1;\n\n    var coord = feature.geometry.coordinates;\n\n    var output = [];\n    var seen = {};\n\n    if (useSpatialIndex) {\n        var allEdgesAsRbushTreeItems = [];\n        for (var ring0 = 0; ring0 < coord.length; ring0++) {\n            for (var edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {\n                allEdgesAsRbushTreeItems.push(rbushTreeItem(ring0, edge0));\n            }\n        }\n        var tree = rbush();\n        tree.load(allEdgesAsRbushTreeItems);\n    }\n\n    for (var ringA = 0; ringA < coord.length; ringA++) {\n        for (var edgeA = 0; edgeA < coord[ringA].length - 1; edgeA++) {\n            if (useSpatialIndex) {\n                var bboxOverlaps = tree.search(rbushTreeItem(ringA, edgeA));\n                bboxOverlaps.forEach(function (bboxIsect) {\n                    var ring1 = bboxIsect.ring;\n                    var edge1 = bboxIsect.edge;\n                    ifIsectAddToOutput(ringA, edgeA, ring1, edge1);\n                });\n            } else {\n                for (var ring1 = 0; ring1 < coord.length; ring1++) {\n                    for (var edge1 = 0; edge1 < coord[ring1].length - 1; edge1++) {\n                        // TODO: speedup possible if only interested in unique: start last two loops at ringA and edgeA+1\n                        ifIsectAddToOutput(ringA, edgeA, ring1, edge1);\n                    }\n                }\n            }\n        }\n    }\n\n    if (!filterFn) output = {type: 'Feature', geometry: {type: 'MultiPoint', coordinates: output}};\n    return output;\n\n    // Function to check if two edges intersect and add the intersection to the output\n    function ifIsectAddToOutput(ring0, edge0, ring1, edge1) {\n        var start0 = coord[ring0][edge0];\n        var end0 = coord[ring0][edge0 + 1];\n        var start1 = coord[ring1][edge1];\n        var end1 = coord[ring1][edge1 + 1];\n\n        var isect = intersect(start0, end0, start1, end1);\n\n        if (isect === null) return; // discard parallels and coincidence\n        var frac0;\n        var frac1;\n        if (end0[0] !== start0[0]) {\n            frac0 = (isect[0] - start0[0]) / (end0[0] - start0[0]);\n        } else {\n            frac0 = (isect[1] - start0[1]) / (end0[1] - start0[1]);\n        }\n        if (end1[0] !== start1[0]) {\n            frac1 = (isect[0] - start1[0]) / (end1[0] - start1[0]);\n        } else {\n            frac1 = (isect[1] - start1[1]) / (end1[1] - start1[1]);\n        }\n        if (frac0 >= 1 || frac0 <= 0 || frac1 >= 1 || frac1 <= 0) return; // require segment intersection\n\n        var key = isect;\n        var unique = !seen[key];\n        if (unique) {\n            seen[key] = true;\n        }\n\n        if (filterFn) {\n            output.push(filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique));\n        } else {\n            output.push(isect);\n        }\n    }\n\n    // Function to return a rbush tree item given an ring and edge number\n    function rbushTreeItem(ring, edge) {\n\n        var start = coord[ring][edge];\n        var end = coord[ring][edge + 1];\n        var minX;\n        var maxX;\n        var minY;\n        var maxY;\n        if (start[0] < end[0]) {\n            minX = start[0];\n            maxX = end[0];\n        } else {\n            minX = end[0];\n            maxX = start[0];\n        }\n        if (start[1] < end[1]) {\n            minY = start[1];\n            maxY = end[1];\n        } else {\n            minY = end[1];\n            maxY = start[1];\n        }\n        return {minX: minX, minY: minY, maxX: maxX, maxY: maxY, ring: ring, edge: edge};\n    }\n};\n\n// Function to compute where two lines (not segments) intersect. From https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\nfunction intersect(start0, end0, start1, end1) {\n    if (equalArrays$1(start0, start1) || equalArrays$1(start0, end1) || equalArrays$1(end0, start1) || equalArrays$1(end1, start1)) return null;\n    var x0 = start0[0],\n        y0 = start0[1],\n        x1 = end0[0],\n        y1 = end0[1],\n        x2 = start1[0],\n        y2 = start1[1],\n        x3 = end1[0],\n        y3 = end1[1];\n    var denom = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3);\n    if (denom === 0) return null;\n    var x4 = ((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / denom;\n    var y4 = ((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / denom;\n    return [x4, y4];\n}\n\n// Function to compare Arrays of numbers. From http://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript\nfunction equalArrays$1(array1, array2) {\n    // if the other array is a falsy value, return\n    if (!array1 || !array2)\n        return false;\n\n    // compare lengths - can save a lot of time\n    if (array1.length !== array2.length)\n        return false;\n\n    for (var i = 0, l = array1.length; i < l; i++) {\n        // Check if we have nested arrays\n        if (array1[i] instanceof Array && array2[i] instanceof Array) {\n            // recurse into the nested arrays\n            if (!equalArrays$1(array1[i], array2[i]))\n                return false;\n        } else if (array1[i] !== array2[i]) {\n            // Warning - two different object instances will never be equal: {x:20} !== {x:20}\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Takes a complex (i.e. self-intersecting) geojson polygon, and breaks it down into its composite simple, non-self-intersecting one-ring polygons.\n *\n * @module simplepolygon\n * @param {Feature} feature Input polygon. This polygon may be unconform the {@link https://en.wikipedia.org/wiki/Simple_Features|Simple Features standard} in the sense that it's inner and outer rings may cross-intersect or self-intersect, that the outer ring must not contain the optional inner rings and that the winding number must not be positive for the outer and negative for the inner rings.\n * @return {FeatureCollection} Feature collection containing the simple, non-self-intersecting one-ring polygon features that the complex polygon is composed of. These simple polygons have properties such as their parent polygon, winding number and net winding number.\n *\n * @example\n * var poly = {\n *   \"type\": \"Feature\",\n *   \"geometry\": {\n *     \"type\": \"Polygon\",\n *     \"coordinates\": [[[0,0],[2,0],[0,2],[2,2],[0,0]]]\n *   }\n * };\n *\n * var result = simplepolygon(poly);\n *\n * // =result\n * // which will be a featureCollection of two polygons, one with coordinates [[[0,0],[2,0],[1,1],[0,0]]], parent -1, winding 1 and net winding 1, and one with coordinates [[[1,1],[0,2],[2,2],[1,1]]], parent -1, winding -1 and net winding -1\n */\nvar simplepolygon = function (feature) {\n    // Check input\n    if (feature.type != 'Feature') throw new Error('The input must a geojson object of type Feature');\n    if ((feature.geometry === undefined) || (feature.geometry == null)) throw new Error('The input must a geojson object with a non-empty geometry');\n    if (feature.geometry.type != 'Polygon') throw new Error('The input must be a geojson Polygon');\n\n    // Process input\n    var numRings = feature.geometry.coordinates.length;\n    var vertices = [];\n    for (var i = 0; i < numRings; i++) {\n        var ring = feature.geometry.coordinates[i];\n        if (!equalArrays(ring[0], ring[ring.length - 1])) {\n            ring.push(ring[0]); // Close input ring if it is not\n        }\n        vertices.push.apply(vertices, ring.slice(0, ring.length - 1));\n    }\n    if (!isUnique(vertices)) throw new Error('The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)');\n    var numvertices = vertices.length; // number of input ring vertices, with the last closing vertices not counted\n\n    // Compute self-intersections\n    var selfIsectsData = isects(feature, function filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique) {\n        return [isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique];\n    });\n    var numSelfIsect = selfIsectsData.length;\n\n    // If no self-intersections are found, the input rings are the output rings. Hence, we must only compute their winding numbers, net winding numbers and (since ohers rings could lie outside the first ring) parents.\n    if (numSelfIsect == 0) {\n        var outputFeatureArray = [];\n        for (var i = 0; i < numRings; i++) {\n            outputFeatureArray.push(polygon([feature.geometry.coordinates[i]], {parent: -1, winding: windingOfRing(feature.geometry.coordinates[i])}));\n        }\n        var output = featureCollection(outputFeatureArray);\n        determineParents();\n        setNetWinding();\n\n        return output;\n    }\n\n    // If self-intersections are found, we will compute the output rings with the help of two intermediate variables\n    // First, we build the pseudo vertex list and intersection list\n    // The Pseudo vertex list is an array with for each ring an array with for each edge an array containing the pseudo-vertices (as made by their constructor) that have this ring and edge as ringAndEdgeIn, sorted for each edge by their fractional distance on this edge. It's length hence equals numRings.\n    var pseudoVtxListByRingAndEdge = [];\n    // The intersection list is an array containing intersections (as made by their constructor). First all numvertices ring-vertex-intersections, then all self-intersections (intra- and inter-ring). The order of the latter is not important but is permanent once given.\n    var isectList = [];\n    // Adding ring-pseudo-vertices to pseudoVtxListByRingAndEdge and ring-vertex-intersections to isectList\n    for (var i = 0; i < numRings; i++) {\n        pseudoVtxListByRingAndEdge.push([]);\n        for (var j = 0; j < feature.geometry.coordinates[i].length - 1; j++) {\n            // Each edge will feature one ring-pseudo-vertex in its array, on the last position. i.e. edge j features the ring-pseudo-vertex of the ring vertex j+1, which has ringAndEdgeIn = [i,j], on the last position.\n            pseudoVtxListByRingAndEdge[i].push([new PseudoVtx(feature.geometry.coordinates[i][(j + 1).modulo(feature.geometry.coordinates[i].length - 1)], 1, [i, j], [i, (j + 1).modulo(feature.geometry.coordinates[i].length - 1)], undefined)]);\n            // The first numvertices elements in isectList correspond to the ring-vertex-intersections\n            isectList.push(new Isect(feature.geometry.coordinates[i][j], [i, (j - 1).modulo(feature.geometry.coordinates[i].length - 1)], [i, j], undefined, undefined, false, true));\n        }\n    }\n    // Adding intersection-pseudo-vertices to pseudoVtxListByRingAndEdge and self-intersections to isectList\n    for (var i = 0; i < numSelfIsect; i++) {\n    // Adding intersection-pseudo-vertices made using selfIsectsData to pseudoVtxListByRingAndEdge's array corresponding to the incomming ring and edge\n        pseudoVtxListByRingAndEdge[selfIsectsData[i][1]][selfIsectsData[i][2]].push(new PseudoVtx(selfIsectsData[i][0], selfIsectsData[i][5], [selfIsectsData[i][1], selfIsectsData[i][2]], [selfIsectsData[i][6], selfIsectsData[i][7]], undefined));\n        // selfIsectsData contains double mentions of each intersection, but we only want to add them once to isectList\n        if (selfIsectsData[i][11]) isectList.push(new Isect(selfIsectsData[i][0], [selfIsectsData[i][1], selfIsectsData[i][2]], [selfIsectsData[i][6], selfIsectsData[i][7]], undefined, undefined, true, true));\n    }\n    var numIsect = isectList.length;\n    // Sort edge arrays of pseudoVtxListByRingAndEdge by the fractional distance 'param'\n    for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\n        for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\n            pseudoVtxListByRingAndEdge[i][j].sort(function (a, b) { return (a.param < b.param) ? -1 : 1; });\n        }\n    }\n\n    // Make a spatial index of intersections, in preperation for the following two steps\n    var allIsectsAsIsectRbushTreeItem = [];\n    for (var i = 0; i < numIsect; i++) {\n        allIsectsAsIsectRbushTreeItem.push({minX: isectList[i].coord[0], minY: isectList[i].coord[1], maxX: isectList[i].coord[0], maxY: isectList[i].coord[1], index: i}); // could pass isect: isectList[i], but not necessary\n    }\n    var isectRbushTree = rbush();\n    isectRbushTree.load(allIsectsAsIsectRbushTreeItem);\n\n    // Now we will teach each intersection in isectList which is the next intersection along both it's [ring, edge]'s, in two steps.\n    // First, we find the next intersection for each pseudo-vertex in pseudoVtxListByRingAndEdge:\n    // For each pseudovertex in pseudoVtxListByRingAndEdge (3 loops) look at the next pseudovertex on that edge and find the corresponding intersection by comparing coordinates\n    for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\n        for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\n            for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {\n                var coordToFind;\n                if (k == pseudoVtxListByRingAndEdge[i][j].length - 1) { // If it's the last pseudoVertex on that edge, then the next pseudoVertex is the first one on the next edge of that ring.\n                    coordToFind = pseudoVtxListByRingAndEdge[i][(j + 1).modulo(feature.geometry.coordinates[i].length - 1)][0].coord;\n                } else {\n                    coordToFind = pseudoVtxListByRingAndEdge[i][j][k + 1].coord;\n                }\n                var IsectRbushTreeItemFound = isectRbushTree.search({minX: coordToFind[0], minY: coordToFind[1], maxX: coordToFind[0], maxY: coordToFind[1]})[0]; // We can take [0] of the result, because there is only one isect correponding to a pseudo-vertex\n                pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn = IsectRbushTreeItemFound.index;\n            }\n        }\n    }\n\n    // Second, we port this knowledge of the next intersection over to the intersections in isectList, by finding the intersection corresponding to each pseudo-vertex and copying the pseudo-vertex' knownledge of the next-intersection over to the intersection\n    for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\n        for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\n            for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {\n                var coordToFind = pseudoVtxListByRingAndEdge[i][j][k].coord;\n                var IsectRbushTreeItemFound = isectRbushTree.search({minX: coordToFind[0], minY: coordToFind[1], maxX: coordToFind[0], maxY: coordToFind[1]})[0]; // We can take [0] of the result, because there is only one isect correponding to a pseudo-vertex\n                var l = IsectRbushTreeItemFound.index;\n                if (l < numvertices) { // Special treatment at ring-vertices: we correct the misnaming that happened in the previous block, since ringAndEdgeOut = ringAndEdge2 for ring vertices.\n                    isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\n                } else { // Port the knowledge of the next intersection from the pseudo-vertices to the intersections, depending on how the edges are labeled in the pseudo-vertex and intersection.\n                    if (equalArrays(isectList[l].ringAndEdge1, pseudoVtxListByRingAndEdge[i][j][k].ringAndEdgeIn)) {\n                        isectList[l].nxtIsectAlongRingAndEdge1 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\n                    } else {\n                        isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\n                    }\n                }\n            }\n        }\n    }\n    // This explains why, eventhough when we will walk away from an intersection, we will walk way from the corresponding pseudo-vertex along edgeOut, pseudo-vertices have the property 'nxtIsectAlongEdgeIn' in stead of some propery 'nxtPseudoVtxAlongEdgeOut'. This is because this property (which is easy to find out) is used in the above for nxtIsectAlongRingAndEdge1 and nxtIsectAlongRingAndEdge2!\n\n    // Before we start walking over the intersections to build the output rings, we prepare a queue that stores information on intersections we still have to deal with, and put at least one intersection in it.\n    // This queue will contain information on intersections where we can start walking from once the current walk is finished, and its parent output ring (the smallest output ring it lies within, -1 if no parent or parent unknown yet) and its winding number (which we can already determine).\n    var queue = [];\n    // For each output ring, add the ring-vertex-intersection with the smalles x-value (i.e. the left-most) as a start intersection. By choosing such an extremal intersections, we are sure to start at an intersection that is a convex vertex of its output ring. By adding them all to the queue, we are sure that no rings will be forgotten. If due to ring-intersections such an intersection will be encountered while walking, it will be removed from the queue.\n    var i = 0;\n    for (var j = 0; j < numRings; j++) {\n        var leftIsect = i;\n        for (var k = 0; k < feature.geometry.coordinates[j].length - 1; k++) {\n            if (isectList[i].coord[0] < isectList[leftIsect].coord[0]) {\n                leftIsect = i;\n            }\n            i++;\n        }\n        // Compute winding at this left-most ring-vertex-intersection. We thus this by using our knowledge that this extremal vertex must be a convex vertex.\n        // We first find the intersection before and after it, and then use them to determine the winding number of the corresponding output ring, since we know that an extremal vertex of a simple, non-self-intersecting ring is always convex, so the only reason it would not be is because the winding number we use to compute it is wrong\n        var isectAfterLeftIsect = isectList[leftIsect].nxtIsectAlongRingAndEdge2;\n        for (var k = 0; k < isectList.length; k++) {\n            if ((isectList[k].nxtIsectAlongRingAndEdge1 == leftIsect) || (isectList[k].nxtIsectAlongRingAndEdge2 == leftIsect)) {\n                var isectBeforeLeftIsect = k;\n                break;\n            }\n        }\n        var windingAtIsect = isConvex([isectList[isectBeforeLeftIsect].coord, isectList[leftIsect].coord, isectList[isectAfterLeftIsect].coord], true) ? 1 : -1;\n\n        queue.push({isect: leftIsect, parent: -1, winding: windingAtIsect});\n    }\n    // Sort the queue by the same criterion used to find the leftIsect: the left-most leftIsect must be last in the queue, such that it will be popped first, such that we will work from out to in regarding input rings. This assumtion is used when predicting the winding number and parent of a new queue member.\n    queue.sort(function (a, b) { return (isectList[a.isect].coord > isectList[b.isect].coord) ? -1 : 1; });\n\n    // Initialise output\n    var outputFeatureArray = [];\n\n    // While the queue is not empty, take the last object (i.e. its intersection) out and start making an output ring by walking in the direction that has not been walked away over yet.\n    while (queue.length > 0) {\n    // Get the last object out of the queue\n        var popped = queue.pop();\n        var startIsect = popped.isect;\n        var currentOutputRingParent = popped.parent;\n        var currentOutputRingWinding = popped.winding;\n        // Make new output ring and add vertex from starting intersection\n        var currentOutputRing = outputFeatureArray.length;\n        var currentOutputRingCoords = [isectList[startIsect].coord];\n        // Set up the variables used while walking over intersections: 'currentIsect', 'nxtIsect' and 'walkingRingAndEdge'\n        var currentIsect = startIsect;\n        if (isectList[startIsect].ringAndEdge1Walkable) {\n            var walkingRingAndEdge = isectList[startIsect].ringAndEdge1;\n            var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge1;\n        } else {\n            var walkingRingAndEdge = isectList[startIsect].ringAndEdge2;\n            var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge2;\n        }\n        // While we have not arrived back at the same intersection, keep walking\n        while (!equalArrays(isectList[startIsect].coord, isectList[nxtIsect].coord)) {\n            currentOutputRingCoords.push(isectList[nxtIsect].coord);\n            // If the next intersection is queued, we can remove it, because we will go there now.\n            var nxtIsectInQueue = undefined;\n            for (var i = 0; i < queue.length; i++) { if (queue[i].isect == nxtIsect) { nxtIsectInQueue = i; break; } }\n            if (nxtIsectInQueue != undefined) {\n                queue.splice(nxtIsectInQueue, 1);\n            }\n            // Arriving at this new intersection, we know which will be our next walking ring and edge (if we came from 1 we will walk away from 2 and vice versa),\n            // So we can set it as our new walking ring and intersection and remember that we (will) have walked over it\n            // If we have never walked away from this new intersection along the other ring and edge then we will soon do, add the intersection (and the parent wand winding number) to the queue\n            // (We can predict the winding number and parent as follows: if the edge is convex, the other output ring started from there will have the alternate winding and lie outside of the current one, and thus have the same parent ring as the current ring. Otherwise, it will have the same winding number and lie inside of the current ring. We are, however, only sure of this of an output ring started from there does not enclose the current ring. This is why the initial queue's intersections must be sorted such that outer ones come out first.)\n            // We then update the other two walking variables.\n            if (equalArrays(walkingRingAndEdge, isectList[nxtIsect].ringAndEdge1)) {\n                walkingRingAndEdge = isectList[nxtIsect].ringAndEdge2;\n                isectList[nxtIsect].ringAndEdge2Walkable = false;\n                if (isectList[nxtIsect].ringAndEdge1Walkable) {\n                    var pushing = {isect: nxtIsect};\n                    if (isConvex([isectList[currentIsect].coord, isectList[nxtIsect].coord, isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge2].coord], currentOutputRingWinding == 1)) {\n                        pushing.parent = currentOutputRingParent;\n                        pushing.winding = -currentOutputRingWinding;\n                    } else {\n                        pushing.parent = currentOutputRing;\n                        pushing.winding = currentOutputRingWinding;\n                    }\n                    queue.push(pushing);\n                }\n                currentIsect = nxtIsect;\n                nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge2;\n            } else {\n                walkingRingAndEdge = isectList[nxtIsect].ringAndEdge1;\n                isectList[nxtIsect].ringAndEdge1Walkable = false;\n                if (isectList[nxtIsect].ringAndEdge2Walkable) {\n                    var pushing = {isect: nxtIsect};\n                    if (isConvex([isectList[currentIsect].coord, isectList[nxtIsect].coord, isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge1].coord], currentOutputRingWinding == 1)) {\n                        pushing.parent = currentOutputRingParent;\n                        pushing.winding = -currentOutputRingWinding;\n                    } else {\n                        pushing.parent = currentOutputRing;\n                        pushing.winding = currentOutputRingWinding;\n                    }\n                    queue.push(pushing);\n                }\n                currentIsect = nxtIsect;\n                nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge1;\n            }\n        }\n        // Close output ring\n        currentOutputRingCoords.push(isectList[nxtIsect].coord);\n        // Push output ring to output\n        outputFeatureArray.push(polygon([currentOutputRingCoords], {index: currentOutputRing, parent: currentOutputRingParent, winding: currentOutputRingWinding, netWinding: undefined}));\n    }\n\n    var output = featureCollection(outputFeatureArray);\n\n    determineParents();\n\n    setNetWinding();\n\n    // These functions are also used if no intersections are found\n    function determineParents() {\n        var featuresWithoutParent = [];\n        for (var i = 0; i < output.features.length; i++) {\n            if (output.features[i].properties.parent == -1) featuresWithoutParent.push(i);\n        }\n        if (featuresWithoutParent.length > 1) {\n            for (var i = 0; i < featuresWithoutParent.length; i++) {\n                var parent = -1;\n                var parentArea = Infinity;\n                for (var j = 0; j < output.features.length; j++) {\n                    if (featuresWithoutParent[i] == j) continue;\n                    if (booleanPointInPolygon(output.features[featuresWithoutParent[i]].geometry.coordinates[0][0], output.features[j], {ignoreBoundary: true})) {\n                        if (area(output.features[j]) < parentArea) {\n                            parent = j;\n                        }\n                    }\n                }\n                output.features[featuresWithoutParent[i]].properties.parent = parent;\n            }\n        }\n    }\n\n    function setNetWinding() {\n        for (var i = 0; i < output.features.length; i++) {\n            if (output.features[i].properties.parent == -1) {\n                var netWinding = output.features[i].properties.winding;\n                output.features[i].properties.netWinding = netWinding;\n                setNetWindingOfChildren(i, netWinding);\n            }\n        }\n    }\n\n    function setNetWindingOfChildren(parent, ParentNetWinding) {\n        for (var i = 0; i < output.features.length; i++) {\n            if (output.features[i].properties.parent == parent) {\n                var netWinding = ParentNetWinding + output.features[i].properties.winding;\n                output.features[i].properties.netWinding = netWinding;\n                setNetWindingOfChildren(i, netWinding);\n            }\n        }\n    }\n\n\n    return output;\n};\n\n\n\n// Constructor for (ring- or intersection-) pseudo-vertices.\nvar PseudoVtx = function (coord, param, ringAndEdgeIn, ringAndEdgeOut, nxtIsectAlongEdgeIn) {\n    this.coord = coord; // [x,y] of this pseudo-vertex\n    this.param = param; // fractional distance of this intersection on incomming edge\n    this.ringAndEdgeIn = ringAndEdgeIn; // [ring index, edge index] of incomming edge\n    this.ringAndEdgeOut = ringAndEdgeOut; // [ring index, edge index] of outgoing edge\n    this.nxtIsectAlongEdgeIn = nxtIsectAlongEdgeIn; // The next intersection when following the incomming edge (so not when following ringAndEdgeOut!)\n};\n\n// Constructor for an intersection. There are two intersection-pseudo-vertices per self-intersection and one ring-pseudo-vertex per ring-vertex-intersection. Their labels 1 and 2 are not assigned a particular meaning but are permanent once given.\nvar Isect = function (coord, ringAndEdge1, ringAndEdge2, nxtIsectAlongRingAndEdge1, nxtIsectAlongRingAndEdge2, ringAndEdge1Walkable, ringAndEdge2Walkable) {\n    this.coord = coord; // [x,y] of this intersection\n    this.ringAndEdge1 = ringAndEdge1; // first edge of this intersection\n    this.ringAndEdge2 = ringAndEdge2; // second edge of this intersection\n    this.nxtIsectAlongRingAndEdge1 = nxtIsectAlongRingAndEdge1; // the next intersection when following ringAndEdge1\n    this.nxtIsectAlongRingAndEdge2 = nxtIsectAlongRingAndEdge2; // the next intersection when following ringAndEdge2\n    this.ringAndEdge1Walkable = ringAndEdge1Walkable; // May we (still) walk away from this intersection over ringAndEdge1?\n    this.ringAndEdge2Walkable = ringAndEdge2Walkable; // May we (still) walk away from this intersection over ringAndEdge2?\n};\n\n// Function to determine if three consecutive points of a simple, non-self-intersecting ring make up a convex vertex, assuming the ring is right- or lefthanded\nfunction isConvex(pts, righthanded) {\n    // 'pts' is an [x,y] pair\n    // 'righthanded' is a boolean\n    if (typeof (righthanded) === 'undefined') righthanded = true;\n    if (pts.length != 3) throw new Error('This function requires an array of three points [x,y]');\n    var d = (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) - (pts[1][1] - pts[0][1]) * (pts[2][0] - pts[0][0]);\n    return (d >= 0) == righthanded;\n}\n\n// Function to compute winding of simple, non-self-intersecting ring\nfunction windingOfRing(ring) {\n    // 'ring' is an array of [x,y] pairs with the last equal to the first\n    // Compute the winding number based on the vertex with the smallest x-value, it precessor and successor. An extremal vertex of a simple, non-self-intersecting ring is always convex, so the only reason it is not is because the winding number we use to compute it is wrong\n    var leftVtx = 0;\n    for (var i = 0; i < ring.length - 1; i++) { if (ring[i][0] < ring[leftVtx][0]) leftVtx = i; }\n    if (isConvex([ring[(leftVtx - 1).modulo(ring.length - 1)], ring[leftVtx], ring[(leftVtx + 1).modulo(ring.length - 1)]], true)) {\n        var winding = 1;\n    } else {\n        var winding = -1;\n    }\n    return winding;\n}\n\n// Function to compare Arrays of numbers. From http://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript\nfunction equalArrays(array1, array2) {\n    // if the other array is a falsy value, return\n    if (!array1 || !array2)\n        return false;\n\n    // compare lengths - can save a lot of time\n    if (array1.length != array2.length)\n        return false;\n\n    for (var i = 0, l = array1.length; i < l; i++) {\n        // Check if we have nested arrays\n        if (array1[i] instanceof Array && array2[i] instanceof Array) {\n            // recurse into the nested arrays\n            if (!equalArrays(array1[i], array2[i]))\n                return false;\n        } else if (array1[i] != array2[i]) {\n            // Warning - two different object instances will never be equal: {x:20} != {x:20}\n            return false;\n        }\n    }\n    return true;\n}\n\n// Fix Javascript modulo for negative number. From http://stackoverflow.com/questions/4467539/javascript-modulo-not-behaving\nNumber.prototype.modulo = function (n) {\n    return ((this % n) + n) % n;\n};\n\n// Function to check if array is unique (i.e. all unique elements, i.e. no duplicate elements)\nfunction isUnique(array) {\n    var u = {};\n    var isUnique = 1;\n    for (var i = 0, l = array.length; i < l; ++i) {\n        if (u.hasOwnProperty(array[i])) {\n            isUnique = 0;\n            break;\n        }\n        u[array[i]] = 1;\n    }\n    return isUnique;\n}\n\n/**\n * Takes a kinked polygon and returns a feature collection of polygons that have no kinks.\n * Uses [simplepolygon](https://github.com/mclaeysb/simplepolygon) internally.\n *\n * @name unkinkPolygon\n * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} geojson GeoJSON Polygon or MultiPolygon\n * @returns {FeatureCollection<Polygon>} Unkinked polygons\n * @example\n * var poly = turf.polygon([[[0, 0], [2, 0], [0, 2], [2, 2], [0, 0]]]);\n *\n * var result = turf.unkinkPolygon(poly);\n *\n * //addToMap\n * var addToMap = [poly, result]\n */\nfunction unkinkPolygon(geojson) {\n    var features = [];\n    flattenEach(geojson, function (feature) {\n        if (feature.geometry.type !== 'Polygon') return;\n        featureEach(simplepolygon(feature), function (poly) {\n            features.push(polygon(poly.geometry.coordinates, feature.properties));\n        });\n    });\n    return featureCollection(features);\n}\n\nexport default unkinkPolygon;\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { feature, isObject, lineString, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","import pointInPolygon from '@turf/boolean-point-in-polygon';\nimport { featureCollection } from '@turf/helpers';\nimport { featureEach, geomEach } from '@turf/meta';\n\n/**\n * Finds {@link Points} that fall within {@link (Multi)Polygon(s)}.\n *\n * @name pointsWithinPolygon\n * @param {Feauture|FeatureCollection<Point>} points Points as input search\n * @param {FeatureCollection|Geoemtry|Feature<Polygon|MultiPolygon>} polygons Points must be within these (Multi)Polygon(s)\n * @returns {FeatureCollection<Point>} points that land within at least one polygon\n * @example\n * var points = turf.points([\n *     [-46.6318, -23.5523],\n *     [-46.6246, -23.5325],\n *     [-46.6062, -23.5513],\n *     [-46.663, -23.554],\n *     [-46.643, -23.557]\n * ]);\n *\n * var searchWithin = turf.polygon([[\n *     [-46.653,-23.543],\n *     [-46.634,-23.5346],\n *     [-46.613,-23.543],\n *     [-46.614,-23.559],\n *     [-46.631,-23.567],\n *     [-46.653,-23.560],\n *     [-46.653,-23.543]\n * ]]);\n *\n * var ptsWithin = turf.pointsWithinPolygon(points, searchWithin);\n *\n * //addToMap\n * var addToMap = [points, searchWithin, ptsWithin]\n * turf.featureEach(ptsWithin, function (currentFeature) {\n *   currentFeature.properties['marker-size'] = 'large';\n *   currentFeature.properties['marker-color'] = '#000';\n * });\n */\nfunction pointsWithinPolygon(points, polygons) {\n    var results = [];\n    geomEach(polygons, function (polygon) {\n        featureEach(points, function (point) {\n            if (pointInPolygon(point, polygon)) results.push(point);\n        });\n    });\n    return featureCollection(results);\n}\n\nexport default pointsWithinPolygon;\n"],"sourceRoot":""}